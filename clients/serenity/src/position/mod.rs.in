#[derive(Serialize, Deserialize, Debug, Copy, Clone)]
pub struct Pos {
    pub x: i16,
    pub y: i16,
}

//TODO: Use #derive?
impl Eq for Pos {}
impl PartialEq for Pos {
    fn eq(&self, other: &Self) -> bool {
        self.x == other.x && self.y == other.y
    }
}

impl Pos {
    pub fn new(x: i16, y: i16) -> Pos {
        return Pos {x: x, y: y};
    }

    #[allow(dead_code)]
    pub fn distance(self, other: Pos) -> i16 {
        let dx: i16 = self.x - other.x;
        let dy: i16 = self.y - other.y;
        let dz: i16 = self.x + self.y - other.x - other.y;

        // cmp::max only takes 2 args
        cmp::max( cmp::max(dx.abs(), dy.abs()), dz.abs())
    }

    #[allow(dead_code)]
    pub fn random_spread(&self, pos: Pos) -> Pos {
        Pos {
            x: pos.x + util::get_rand_range(-2, 2),
            y: pos.y + util::get_rand_range(-2, 2)
        }
    }

    #[allow(dead_code)]
    pub fn neighbors(&self, radius: &i16) -> Vec<Pos> {
        let mut result: Vec<Pos> = Vec::new();
        let x_min = self.x - radius;
        let x_max = self.x + radius;
        let y_min = self.y - radius;
        let y_max = self.y + radius;

        for x in x_min..x_max {
            for y in y_min..y_max {
                let new_pos = Pos { x: x, y: y };
                if self.distance(new_pos) <= *radius && *self != new_pos {
                    result.push(new_pos);
                }
            }
        }

        result
    }

    #[allow(dead_code)]
    pub fn clamped_neighbors(&self, radius: &i16, field_radius: &i16) -> Vec<Pos> {
        let mut result: Vec<Pos> = Vec::new();
        let x_min = self.x - radius;
        let x_max = self.x + radius;
        let y_min = self.y - radius;
        let y_max = self.y + radius;

        for x in x_min..x_max {
            for y in y_min..y_max {
                let new_pos = Pos { x: x, y: y };
                if self.distance(new_pos) <= *radius && *self != new_pos {
                    result.push(new_pos);
                }
            }
        }

        result
            .iter()
            .cloned()
            .filter(|p| p.x.abs() <= *field_radius && p.y.abs() <= *field_radius)
            .collect()
    }

    pub fn triangle_smart(&self) -> Vec<Pos> {
        return match rand::thread_rng().gen_range(0, 2) {
            0 => { self.triangle_down() }
            _ => { self.triangle_up() }
        }
    }

    // TODO: Generalize for shot radius
    pub fn triangle_down(&self) -> Vec<Pos> {
        let x = self.x;
        let y = self.y;
        return vec![ Pos::new(x-1, y+2),
                     Pos::new(x+2, y-1),
                     Pos::new(x-1, y-1) ];
    }

    // TODO: Generalize for shot radius
    pub fn triangle_up(&self) -> Vec<Pos> {
        let x = self.x;
        let y = self.y;
        return vec![ Pos::new(x+1, y-2),
                     Pos::new(x-2, y+1),
                     Pos::new(x+1, y+1) ];
    }
}

impl Add for Pos {
    type Output = Pos;

    fn add(self, other: Pos) -> Pos {
        Pos { x: self.x + other.x, y: self.y + other.y }
    }
}
